module Ocelot.Component.SearchBar where

import Prelude

import TailwindClasses as TailwindClasses
import Control.Monad.State (class MonadState)
import Data.Maybe (Maybe(..), fromMaybe)
import Data.String (null)
import Data.Time.Duration (Milliseconds(..))
import Effect.Aff (Fiber, delay, forkAff, killFiber)
import Effect.Aff.AVar (AVar)
import Effect.Aff.AVar as AVar
import Effect.Aff.Class (class MonadAff)
import Effect.Exception (error)
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP
import Ocelot.Block.Icon as Icon
import Ocelot.HTML.Properties (css)
import Web.Event.Event (stopPropagation)
import Web.UIEvent.MouseEvent as ME

type State =
  { query :: String
  , debouncer :: Maybe Debouncer
  , debounceTime :: Milliseconds
  , open :: Boolean
  , keepOpen :: Boolean
  }

type Debouncer =
  { var :: AVar String
  , fiber :: Fiber Unit
  }


data Action
  = Clear ME.MouseEvent
  | Search String
  | Open
  | Blur

data Query a
  = SetText String a

type Slot = H.Slot Query Message

type Input = { debounceTime :: Maybe Milliseconds }
type Input' =
  { debounceTime :: Maybe Milliseconds
  , keepOpen :: Boolean
  }

data Message
 = Searched String

-- | The standard search bar
component :: ∀ m. MonadAff m => H.Component HH.HTML Query Input Message m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval (H.defaultEval { handleQuery = handleQuery, handleAction = handleAction })
    }

  where
    initialState :: Input -> State
    initialState { debounceTime } =
      { query: ""
      , debouncer: Nothing
      , debounceTime: fromMaybe (Milliseconds 0.0) debounceTime
      , open: false
      , keepOpen: false
      }

-- | A search bar which allows the user to specify if it should
-- | stay open when unfocused
component' :: ∀ m. MonadAff m => H.Component HH.HTML Query Input' Message m
component' =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval (H.defaultEval { handleQuery = handleQuery, handleAction = handleAction })
    }

  where
    initialState :: Input' -> State
    initialState { debounceTime, keepOpen } =
      { query: ""
      , debouncer: Nothing
      , debounceTime: fromMaybe (Milliseconds 0.0) debounceTime
      , open: keepOpen
      , keepOpen
      }

handleAction :: forall m.
  MonadAff m =>
  Action ->
  H.HalogenM State Action () Message m Unit
handleAction = case _ of
  Open -> do
    H.modify_ _ { open = true }

  Blur -> do
    { query } <- H.get
    closeIfNullQuery query

  Clear ev -> do
    H.liftEffect $ stopPropagation $ ME.toEvent ev
    H.modify_ \st -> st { query = "", open = st.keepOpen }
    H.raise $ Searched ""

  Search str -> do
    H.modify_ _ { query = str }
    openIfHasQuery str
    st <- H.get

    case st.debouncer of
      Nothing -> unit <$ do
        var <- H.liftAff AVar.empty
        fiber <- H.liftAff $ forkAff do
          delay st.debounceTime
          AVar.put str var

        _ <- H.fork do
          val <- H.liftAff $ AVar.take var
          H.modify_ _ { debouncer = Nothing }
          H.raise $ Searched val

        H.modify_ _ { debouncer = Just { var, fiber } }

      Just ({ var, fiber }) -> unit <$ do
        _ <- H.liftAff $ killFiber (error "Debounce restarted") fiber
        fiber' <- H.liftAff $ forkAff do
          delay st.debounceTime
          AVar.put str var

        H.modify_ _ { debouncer = Just { var, fiber: fiber' }}

handleQuery :: forall m a.
  MonadAff m =>
  Query a ->
  H.HalogenM State Action () Message m (Maybe a)
handleQuery = case _ of
  -- For when there is an existing search performed, but you need to set the
  -- field's text anyway.
  SetText str a -> do
    H.modify_ _ { query = str }
    openIfHasQuery str
    pure $ Just a

openIfHasQuery :: forall m.
  MonadState State m =>
  String ->
  m Unit
openIfHasQuery q =
  if null q then pure unit else H.modify_ _ { open = true }

closeIfNullQuery :: forall m.
  MonadState State m =>
  String ->
  m Unit
closeIfNullQuery q = do
  if null q then H.modify_ \st -> st { open = st.keepOpen } else pure unit

render :: forall m.
  MonadAff m =>
  State ->
  H.ComponentHTML Action () m
render st@{ query, open } =
  HH.label
    [ HP.classes $ containerClasses <> containerCondClasses
    , HE.onClick (Just <<< const Open)
    ]
    [ HH.div
      [ HP.classes $ iconClasses <> iconCondClasses ]
      [ Icon.search_ ]
    , HH.div
      [ HP.classes [ TailwindClasses.flex_grow ] ]
      [ HH.input
        [ HE.onValueInput (Just <<< Search)
        , HP.placeholder "Search"
        , HP.value query
        , HP.classes $ inputClasses <> inputCondClasses
        , HE.onBlur (Just <<< const Blur)
        , HP.tabIndex 0
        ]
      ]
    , HH.button
      [ HE.onClick $ Just <<< Clear
      , HP.type_ HP.ButtonButton
      , HP.classes $ buttonClasses <> buttonCondClasses <> keepOpenClasses
      ]
      [ Icon.delete_ ]
    ]
   where
     containerClasses =
       [ TailwindClasses.flex
       , TailwindClasses.no_outline
       , TailwindClasses.items_stretch
       , TailwindClasses.transition_1_over_4
       , TailwindClasses.border_b_2
       , TailwindClasses.group
       ]

     containerCondClasses =
       ifOpen
         [ TailwindClasses.max_w_160
         , TailwindClasses.border_blue_88
         ]
         [ TailwindClasses.max_w_12
         , TailwindClasses.border_transparent
         , TailwindClasses.cursor_pointer
         ]

     iconClasses =
       [ TailwindClasses.pr_3
       , TailwindClasses.text_2xl
       , HH.ClassName "group-hover:text-gray-50"
       , TailwindClasses.transition_1_over_4
       ]

     iconCondClasses =
       ifOpen
         [ TailwindClasses.text_gray_50
         , TailwindClasses.mb_0
         , TailwindClasses.mt_0
         ]
         [ TailwindClasses.text_gray_70
         , HH.ClassName "-mb-1"
         , TailwindClasses.mt_1
         ]

     inputClasses =
       [ TailwindClasses.no_outline
       , TailwindClasses.flex_1
       , TailwindClasses.bg_transparent
       , TailwindClasses.h_full
       , TailwindClasses.transition_1_over_4
       ]

     inputCondClasses =
       ifOpen
         [ TailwindClasses.w_full
         ]
         [ TailwindClasses.w_0
         ]

     buttonClasses =
       [ TailwindClasses.no_outline
       , TailwindClasses.text_gray_70
       , HH.ClassName "hover:text-gray-50"
       , TailwindClasses.text_xs
       , TailwindClasses.transition_1_over_4
       , TailwindClasses.flex_shrink
       ]

     buttonCondClasses =
       ifOpen
         [ TailwindClasses.opacity_100
         , TailwindClasses.visible
         ]
         [ TailwindClasses.opacity_0
         , TailwindClasses.invisible
         ]

     keepOpenClasses =
       if st.keepOpen
         then
          [ TailwindClasses.hidden
          ]
         else []

     ifOpen openClasses closedClasses =
        if open then openClasses else closedClasses
